# Monkey patch for Python 3.12:
import collections
import collections.abc
if not hasattr(collections, 'MutableMapping'):
    collections.MutableMapping = collections.abc.MutableMapping

import time
import cv2
import cv2.aruco as aruco
import numpy as np
from dronekit import connect, VehicleMode
from pymavlink import mavutil

# ----- CONFIGURATION CONSTANTS -----
# Set hover velocity (zero velocity for stop/hover)
HOVER_VELOCITY = 0.0       # No movement
COMMAND_DURATION = 1       # Duration (seconds) for each velocity command
GPS_TARGET_MARKER_ID = 23  # The ArUco marker ID that triggers descent (if needed)
NO_MARKER_TIMEOUT = 20     # Maximum hover time (in seconds) before landing if no marker is seen
SERIAL_BAUD = 57600        # Baud rate for Pixhawk connection
CONNECTION_STRINGS = ['/dev/ttyAMA0', '/dev/ttyACM0', '/dev/serial0']

# ----- Helper Functions -----
def send_ned_velocity(vehicle, velocity_x, velocity_y, velocity_z, duration):
    """
    Sends command to the drone to move with specified velocities (m/s) in local NED.
    In NED, velocity_z < 0 means upward; velocity_z > 0 means downward.
    For a hover we send zero velocities.
    """
    msg = vehicle.message_factory.set_position_target_local_ned_encode(
        0,      # time_boot_ms (not used)
        0, 0,   # target system, target component
        mavutil.mavlink.MAV_FRAME_LOCAL_NED,  # frame
        0b0000111111000111,                   # type_mask (only velocity enabled)
        0, 0, 0,                              # x, y, z positions (not used)
        velocity_x, velocity_y, velocity_z,    # velocities in m/s
        0, 0, 0,                              # accelerations (not supported)
        0, 0                                  # yaw, yaw_rate (not used)
    )
    print(f"Sending NED velocity: vx={velocity_x}, vy={velocity_y}, vz={velocity_z} for {duration}s")
    end_time = time.time() + duration
    while time.time() < end_time:
        vehicle.send_mavlink(msg)
        time.sleep(0.1)

def try_connect(connection_string, baud=SERIAL_BAUD):
    try:
        print(f"Trying connection string: {connection_string}")
        vehicle = connect(connection_string, baud=baud, wait_ready=False, heartbeat_timeout=60)
        print("Connected successfully using:", connection_string)
        return vehicle
    except Exception as e:
        print(f"Error connecting using {connection_string}: {e}")
        return None

def connect_pixhawk():
    vehicle = None
    for cs in CONNECTION_STRINGS:
        vehicle = try_connect(cs)
        if vehicle is not None:
            break
    if vehicle is None:
        print("Failed to connect to Pixhawk on any provided port.")
    return vehicle

# ----- MAIN CODE -----
def main():
    # Connect to the Pixhawk autopilot.
    print("Connecting to Pixhawk autopilot...")
    vehicle = connect_pixhawk()
    if vehicle is None:
        return

    # Allow a brief delay for initial telemetry.
    time.sleep(2)

    # Arm the vehicle (without a takeoff routine, so motors should spin up).
    print("Arming vehicle...")
    while not vehicle.is_armable:
        print(" Waiting for vehicle to become armable...")
        time.sleep(1)
    vehicle.mode = VehicleMode("GUIDED")
    vehicle.armed = True
    while not vehicle.armed:
        print(" Waiting for arming...")
        time.sleep(1)
    print("Vehicle armed. Hovering in place for up to 20 seconds while scanning for an ArUco marker.")

    # Open the camera using a GStreamer pipeline (suitable for Raspberry Pi).
    cv2.namedWindow("ArUco Detection", cv2.WINDOW_NORMAL)
    cap = cv2.VideoCapture(
        "libcamerasrc ! video/x-raw,format=NV12,width=1920,height=1080,framerate=30/1 ! "
        "videoconvert ! videoscale ! video/x-raw,format=BGR ! appsink",
        cv2.CAP_GSTREAMER
    )
    if not cap.isOpened():
        print("Error: Could not open camera.")
        vehicle.close()
        return

    # Initialize ArUco marker detection.
    aruco_dict = aruco.getPredefinedDictionary(aruco.DICT_4X4_50)
    parameters = aruco.DetectorParameters_create()

    # Start the hover and detection loop.
    detection_start_time = time.time()
    marker_detected = False

    try:
        while True:
            ret, frame = cap.read()
            if not ret:
                print("Failed to capture frame from camera.")
                continue

            # Determine the center of the frame.
            frame_height, frame_width = frame.shape[:2]
            frame_center = (frame_width // 2, frame_height // 2)
            cv2.circle(frame, frame_center, 5, (255, 0, 0), -1)  # Blue dot at center

            # Convert frame to grayscale and detect ArUco markers.
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            corners, ids, _ = aruco.detectMarkers(gray, aruco_dict, parameters=parameters)

            if ids is not None:
                print("Detected markers with IDs:", ids.flatten())
                # For this example we consider any detected marker as the landing trigger,
                # regardless of its orientation or position.
                marker_detected = True
                # Optionally, you could add extra checks on marker position/orientation here.
                cv2.putText(frame, "Marker Detected!", (30, 30),
                            cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 0, 255), 2)
                # Break out of the detection loop.
                print("Marker detected. Initiating landing sequence.")
                cv2.imshow("ArUco Detection", frame)
                cv2.waitKey(500)
                break

            # Display guidance (if desired, you can add overlay text here).
            cv2.putText(frame, "Hovering...", (30, 30),
                        cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 255, 0), 2)
            cv2.imshow("ArUco Detection", frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

            # Check if 20 seconds have elapsed.
            elapsed = time.time() - detection_start_time
            if elapsed > NO_MARKER_TIMEOUT:
                print("No marker detected within 20 seconds.")
                break

            # While hovering, send a zero velocity command.
            send_ned_velocity(vehicle, 0, 0, HOVER_VELOCITY, COMMAND_DURATION)
    except KeyboardInterrupt:
        print("User interrupted the detection loop.")

    # Command landing regardless of detection.
    print("Commanding landing...")
    vehicle.mode = VehicleMode("LAND")
    # Allow some time for landing command to be processed.
    time.sleep(10)

    # Cleanup resources.
    cap.release()
    cv2.destroyAllWindows()
    vehicle.close()
    print("Shutdown complete.")

if __name__ == '__main__':
    main()
